# .CLAUDE.md - Export Dashboard Development Guide

This file provides guidance to Claude Code and AI agents when working on the Export Dashboard project.

## Project Overview

The Export Dashboard is a comprehensive web application for visualizing and analyzing South Korea's export statistics data. The project follows Clean Architecture and Domain-Driven Design (DDD) principles with a modern full-stack implementation.

### Core Technologies
- **Backend**: Spring Boot 3.2.0, Java 17, PostgreSQL 15, Redis 7
- **Frontend**: Vue 3.3.8, TypeScript 5.2.2, TailwindCSS 3.3.5
- **Infrastructure**: Docker, Docker Compose, Nginx

## Documentation Structure

All project documentation is located in the `docs/` folder with the following files:

### Key Documentation Files
1. **export_planner_spec.md** - Comprehensive project specification including:
   - Business objectives and requirements
   - Technical architecture and design patterns
   - Technology stack and dependencies
   - Project timeline and milestones (currently 60% complete)
   - Risk assessment and KPIs

2. **export_api_spec.md** - Complete API specification including:
   - RESTful API endpoints with request/response examples
   - Data models and validation rules
   - Error handling patterns
   - Caching strategy with Redis
   - Performance optimization guidelines

3. **sql.md** - Database schema documentation including:
   - Complete table definitions with column details
   - Entity relationships and foreign keys
   - Indexes and performance optimization
   - Sample data and query patterns
   - Backup and maintenance procedures

**IMPORTANT**: Always refer to these documentation files when:
- Implementing new features
- Making architectural decisions
- Understanding business requirements
- Working with database schema
- Designing API endpoints

## Architecture Patterns

### Backend Architecture (Hexagonal/Clean Architecture)

```
src/main/java/com/posces/exportdashboard/
‚îú‚îÄ‚îÄ domain/                    # Core Business Logic (No dependencies)
‚îÇ   ‚îú‚îÄ‚îÄ model/                # Aggregate roots and entities
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Country           # Country aggregate
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ProductCategory   # Product category aggregate
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ExportStatistic   # Export statistic aggregate
‚îÇ   ‚îú‚îÄ‚îÄ event/                # Domain events
‚îÇ   ‚îú‚îÄ‚îÄ service/              # Domain services
‚îÇ   ‚îî‚îÄ‚îÄ repository/           # Repository interfaces (ports)
‚îÇ
‚îú‚îÄ‚îÄ application/              # Use Cases / Application Services
‚îÇ   ‚îú‚îÄ‚îÄ service/              # Application services (orchestration)
‚îÇ   ‚îî‚îÄ‚îÄ dto/                  # Data Transfer Objects
‚îÇ
‚îú‚îÄ‚îÄ infrastructure/           # External Concerns
‚îÇ   ‚îú‚îÄ‚îÄ persistence/          # JPA implementations
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ entity/          # JPA entities
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ repository/      # JPA repository implementations
‚îÇ   ‚îî‚îÄ‚îÄ config/              # Spring configuration
‚îÇ
‚îî‚îÄ‚îÄ interfaces/               # API Layer
    ‚îî‚îÄ‚îÄ rest/                 # REST controllers
```

### Key Backend Design Patterns
- **Aggregate Root Pattern**: Ensures data consistency within domain boundaries
- **Value Objects**: Immutable objects (Money, Percentage, CountryCode, HsCode)
- **Domain Events**: Event-driven architecture for cross-aggregate communication
- **Repository Pattern**: Data access abstraction with interface/implementation separation
- **Application Services**: Orchestrate use cases and coordinate domain objects

### Frontend Architecture (Vue 3 Composition API)

```
src/
‚îú‚îÄ‚îÄ components/               # Reusable UI components
‚îÇ   ‚îú‚îÄ‚îÄ common/              # Common components (buttons, inputs, etc.)
‚îÇ   ‚îî‚îÄ‚îÄ dashboard/           # Dashboard-specific components
‚îú‚îÄ‚îÄ views/                   # Page components
‚îú‚îÄ‚îÄ stores/                  # Pinia state management
‚îú‚îÄ‚îÄ services/                # API service layer
‚îú‚îÄ‚îÄ types/                   # TypeScript type definitions
‚îú‚îÄ‚îÄ composables/             # Vue composition functions
‚îî‚îÄ‚îÄ utils/                   # Utility functions
```

## Development Guidelines

### When Working on Backend Features

1. **Always Start with Domain Layer**
   - Define aggregates and entities first
   - Implement business logic in domain services
   - Use value objects for domain concepts

2. **Follow Clean Architecture Dependencies**
   - Domain layer has NO external dependencies
   - Application layer depends only on domain
   - Infrastructure and interfaces depend on both

3. **Database Operations**
   - Refer to `docs/sql.md` for schema details
   - Use proper indexes (documented in sql.md)
   - Follow naming conventions (snake_case for DB, camelCase for Java)

4. **API Implementation**
   - Follow patterns in `docs/export_api_spec.md`
   - Implement proper validation using Jakarta Validation
   - Use DTOs for request/response (never expose entities)
   - Document API changes in export_api_spec.md

5. **Caching Strategy**
   - Dashboard Summary: 30 minutes TTL
   - Countries/Product Categories: 1 hour TTL
   - Export Statistics: 15 minutes TTL
   - Use cache keys format: `{category}::{identifier}`

### When Working on Frontend Features

1. **Component Development**
   - Use Vue 3 Composition API (not Options API)
   - Implement TypeScript interfaces for all props and emits
   - Follow TailwindCSS utility-first approach

2. **State Management**
   - Use Pinia for global state
   - Keep component-local state when possible
   - Implement proper TypeScript typing for stores

3. **API Integration**
   - Use Axios service layer
   - Implement proper error handling
   - Show loading states for async operations

4. **Data Visualization**
   - Use Recharts for charts and graphs
   - Follow responsive design principles
   - Implement progressive loading for large datasets

### Testing Requirements

#### Backend Testing (>80% coverage target)
- **Unit Tests**: JUnit 5, Mockito for domain and application layers
- **Integration Tests**: Testcontainers for database integration
- **Architecture Tests**: ArchUnit for enforcing architectural rules
- **Test Naming**: `should_{expected_behavior}_when_{condition}`

#### Frontend Testing
- **Unit Tests**: Vitest for component testing
- **E2E Tests**: Consider Cypress or Playwright
- **Type Checking**: Use `vue-tsc` for TypeScript validation

## Common Development Tasks

### Adding a New API Endpoint

1. **Define Domain Model** (if needed)
   ```java
   // src/main/java/com/posces/exportdashboard/domain/model/
   public class YourAggregate {
       // Domain logic here
   }
   ```

2. **Create Application Service**
   ```java
   // src/main/java/com/posces/exportdashboard/application/service/
   @Service
   public class YourApplicationService {
       // Use case orchestration
   }
   ```

3. **Implement Repository** (if needed)
   ```java
   // Domain interface
   public interface YourRepository {
       // Port definition
   }

   // Infrastructure implementation
   @Repository
   public class YourRepositoryImpl implements YourRepository {
       // JPA implementation
   }
   ```

4. **Create REST Controller**
   ```java
   // src/main/java/com/posces/exportdashboard/interfaces/rest/
   @RestController
   @RequestMapping("/api/your-resource")
   public class YourController {
       // API endpoints
   }
   ```

5. **Update API Documentation**
   - Add endpoint details to `docs/export_api_spec.md`
   - Include request/response examples
   - Document validation rules

### Adding a New Vue Component

1. **Create Component File**
   ```vue
   <script setup lang="ts">
   // Component logic using Composition API
   </script>

   <template>
     <!-- Template with TailwindCSS -->
   </template>
   ```

2. **Define TypeScript Interfaces**
   ```typescript
   // src/types/your-feature.ts
   export interface YourType {
       // Type definition
   }
   ```

3. **Implement Pinia Store** (if needed)
   ```typescript
   // src/stores/your-feature.ts
   export const useYourStore = defineStore('your-feature', () => {
       // State, actions, getters
   })
   ```

### Database Schema Changes

1. **Review Current Schema**
   - Refer to `docs/sql.md` for existing tables
   - Check foreign key relationships
   - Review existing indexes

2. **Create Migration File**
   - Use Flyway versioning: `V{number}__{description}.sql`
   - Include rollback considerations
   - Update triggers if needed

3. **Update Documentation**
   - Update `docs/sql.md` with schema changes
   - Document new indexes and constraints
   - Add sample queries for new tables

## Docker and Local Development

### Starting Development Environment

```bash
# Start databases only (recommended for local development)
./scripts/start-dev.sh

# Or manually
docker-compose -f docker/docker-compose.dev.yml up -d
```

### Starting Production Environment

```bash
# Full stack with Docker
./scripts/start-prod.sh

# Or manually
docker-compose up -d
```

### Useful Docker Commands

```bash
# View logs
docker-compose logs -f backend
docker-compose logs -f frontend

# Restart specific service
docker-compose restart backend

# Rebuild after code changes
docker-compose up -d --build backend

# Database access
docker exec -it export-dashboard-postgres psql -U export_user -d export_dashboard
```

## Environment Configuration

### Backend Configuration (`application.yml`)
- **Development**: `spring.profiles.active=dev`
- **Production**: `spring.profiles.active=prod`
- **Database**: Configure in `application-{profile}.yml`
- **Redis**: Configure host and port per environment

### Frontend Configuration
- **API Base URL**: Set in `.env.development` and `.env.production`
- **Environment Variables**: Use `VITE_` prefix for Vite

## Performance Considerations

### Backend Performance
1. **Use proper indexes** - Refer to `docs/sql.md` for index strategy
2. **Implement caching** - Follow caching TTL guidelines
3. **Use pagination** - Default page size: 20 items
4. **Optimize queries** - Use EXPLAIN ANALYZE for slow queries
5. **Connection pooling** - Configure HikariCP properly

### Frontend Performance
1. **Lazy loading** - Use dynamic imports for routes
2. **Code splitting** - Leverage Vite's automatic code splitting
3. **Image optimization** - Use appropriate formats and sizes
4. **Progressive loading** - Show skeleton screens
5. **Debounce searches** - Avoid excessive API calls

## Security Best Practices

### Current Security Status
‚ö†Ô∏è **Note**: Current implementation is for development/demo purposes

### Production Security Checklist
- [ ] Implement JWT authentication
- [ ] Add role-based access control (RBAC)
- [ ] Enable HTTPS/TLS
- [ ] Implement API rate limiting
- [ ] Add input validation and sanitization
- [ ] Configure CORS properly
- [ ] Implement security headers
- [ ] Add audit logging

## Troubleshooting

### Common Backend Issues
- **Database connection fails**: Check PostgreSQL container status
- **Redis connection fails**: Verify Redis container is running
- **Port conflicts**: Check if ports 8080, 5432, 6379 are available
- **Build failures**: Run `./mvnw clean install` to rebuild

### Common Frontend Issues
- **API calls fail**: Verify backend is running and CORS is configured
- **Build errors**: Clear node_modules and reinstall dependencies
- **TypeScript errors**: Run `npm run type-check` for details
- **Styling issues**: Rebuild Tailwind with `npm run build`

## Code Quality Standards

### Backend Standards
- **Java Style**: Follow Google Java Style Guide
- **Test Coverage**: Maintain >80% code coverage
- **Documentation**: Use JavaDoc for public APIs
- **Validation**: Use Jakarta Validation annotations
- **Error Handling**: Implement global exception handlers

### Frontend Standards
- **TypeScript**: Enable strict mode
- **Linting**: Use ESLint with Vue plugin
- **Formatting**: Use Prettier for consistent formatting
- **Naming**: Use camelCase for variables, PascalCase for components
- **Comments**: Document complex logic and business rules

## Project Status and Roadmap

### Current Status: ~60% Complete

**Completed** ‚úÖ
- Project structure and containerization
- Backend domain model and business logic
- Database schema and JPA mappings
- REST API endpoints with validation
- Frontend component architecture
- Basic dashboard functionality

**In Progress** üîÑ
- Advanced chart components
- Error handling and user feedback
- Data validation and sanitization

**Pending** ‚ùå
- Comprehensive testing suite
- Performance optimization
- Security hardening
- Production deployment configuration
- Monitoring and alerting

### Upcoming Milestones
1. **Phase 4**: Integration and Testing (Weeks 7-8)
2. **Phase 5**: Deployment and Documentation (Weeks 9-10)

## Getting Help

### Documentation Resources
1. Review `docs/export_planner_spec.md` for business requirements
2. Check `docs/export_api_spec.md` for API details
3. Consult `docs/sql.md` for database schema

### External Resources
- Spring Boot Docs: https://spring.io/projects/spring-boot
- Vue 3 Docs: https://vuejs.org/
- PostgreSQL Docs: https://www.postgresql.org/docs/
- Redis Docs: https://redis.io/docs/

## Important Reminders for AI Agents

1. **Always Read Documentation First**: Before implementing features, review the relevant docs in the `docs/` folder
2. **Follow Clean Architecture**: Respect layer boundaries and dependency rules
3. **Update Documentation**: When making changes, update the corresponding .md files
4. **Test Thoroughly**: Write tests following the patterns in existing test files
5. **Security Awareness**: Be mindful of security implications for production deployment
6. **Performance First**: Consider performance impact of database queries and API calls
7. **Type Safety**: Leverage TypeScript and Java type systems fully
8. **Consistent Patterns**: Follow existing patterns in the codebase

## Contact and Support

- Project Repository: `D:\export-dashboard\`
- Documentation: `D:\export-dashboard\docs\`
- Issues: Track in project management tool
- Code Reviews: Follow team guidelines
