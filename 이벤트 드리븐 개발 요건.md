# Export Dashboard 프로젝트: RabbitMQ & 이벤트 드리븐 아키텍처 적용 분석 보고서

## 목차
1. [현재 아키텍처 평가](#1-현재-아키텍처-평가)
2. [RabbitMQ 적용 가능 영역 분석](#2-rabbitmq-적용-가능-영역-분석)
3. [이벤트 드리븐 아키텍처 적용 영역](#3-이벤트-드리븐-아키텍처-적용-영역)
4. [구체적인 적용 제안 및 우선순위](#4-구체적인-적용-제안-및-우선순위)
5. [구현 시 고려사항](#5-구현-시-고려사항)
6. [예상 이점 요약](#6-예상-이점-요약)
7. [최종 권장 사항](#7-최종-권장-사항)

---

## 1. 현재 아키텍처 평가

### 1.1 프로젝트 구조
**아키텍처 패턴**: DDD (Domain-Driven Design) 기반 모놀리식 아키텍처
- **기술 스택**: Spring Boot 3.2.0, Java 17, PostgreSQL, Redis
- **레이어 구조**:
  - `domain`: Aggregate Root, Value Objects, Domain Events, Domain Services
  - `application`: Application Services (유스케이스 조율)
  - `infrastructure`: Repository 구현, JPA 엔티티 매핑
  - `interfaces`: REST Controllers

### 1.2 도메인 이벤트 인프라 현황

**긍정적 발견사항**:
프로젝트는 이미 도메인 이벤트 기반 설계를 부분적으로 구현하고 있습니다.

**구현된 이벤트**:
1. `ExportStatisticCreated` - backend/src/main/java/com/export/dashboard/domain/event/ExportStatisticCreated.java
2. `ExportStatisticUpdated` - backend/src/main/java/com/export/dashboard/domain/event/ExportStatisticUpdated.java
3. `ExportThresholdExceeded` - backend/src/main/java/com/export/dashboard/domain/event/ExportThresholdExceeded.java
4. `CountryActivated` - backend/src/main/java/com/export/dashboard/domain/event/CountryActivated.java
5. `CountryDeactivated` - backend/src/main/java/com/export/dashboard/domain/event/CountryDeactivated.java
6. `ProductCategoryCreated` - backend/src/main/java/com/export/dashboard/domain/event/ProductCategoryCreated.java

**문제점**:
- **이벤트가 발행되지만 소비되지 않음**: `AggregateRoot.java:15-40`에서 이벤트를 등록하지만, 실제로 발행하는 메커니즘이 없음
- **이벤트 발행 인프라 부재**: Spring의 `ApplicationEventPublisher`나 외부 메시지 브로커 연동이 없음
- **이벤트는 도메인 모델에만 저장되고 활용되지 않음**

### 1.3 데이터 흐름 및 의존성

**현재 동기 처리 플로우**:
```
Client Request → Controller → Application Service → Domain Service → Repository → Database
                                                  ↓
                                            Cache (Redis)
```

**병목 지점**:
1. **대시보드 요약 생성**: `ExportAnalyticsDomainService.java:29-67` - 복잡한 집계 쿼리를 동기적으로 실행
2. **통계 분석**: `ExportAnalyticsDomainService.java:71-217` - HHI 계산, 계절성 분석, CAGR 계산 등 CPU 집약적 작업
3. **배치 업데이트**: `ExportStatisticDomainService.java:164-167` - 대량 데이터 성장률/시장점유율 재계산

---

## 2. RabbitMQ 적용 가능 영역 분석

### 2.1 우선순위 높음: 관세청 API 배치 작업 (계획 중)

**위치**: `관세청 API 요청 개발 요건.md:148-258`

**현재 계획**:
- 월 1회 관세청 API 호출하여 수출/수입 데이터 수집
- Spring Batch 기반 구현 예정
- Excel 파일 처리 및 API Rate Limiting 필요

**RabbitMQ 적용 제안**:

```
[Scheduler]
    → RabbitMQ Exchange (topic: customs.data.sync)
        ↓
    Queue 1: excel-processing-queue
        → Excel 파일 읽기 → HS코드 추출
        → 완료 시 customs.api.request 이벤트 발행

    Queue 2: api-request-queue
        → Rate-limited API 호출 (재시도 로직)
        → 데이터 수신 시 customs.data.received 이벤트 발행

    Queue 3: data-processing-queue
        → 데이터 변환 및 검증
        → DB 저장 (UPSERT)
        → export.statistic.created 이벤트 발행

    Queue 4: notification-queue
        → 배치 완료 알림 (Slack/Email)
```

**이점**:
- **탄력성**: API 장애 시 자동 재시도 (Dead Letter Queue 활용)
- **Rate Limiting**: 메시지 소비 속도 제어로 API 호출 제한 준수
- **모니터링**: RabbitMQ Management UI로 배치 진행 상황 추적
- **확장성**: Worker 인스턴스 추가로 처리 속도 향상

### 2.2 우선순위 높음: 대시보드 분석 작업 비동기 처리

**현재 문제점**:
`ExportStatisticApplicationService.java:150-197` - 대시보드 요약 및 분석 API가 동기 실행

```java
@Cacheable(value = "dashboard-summary", key = "#year")
public DashboardSummaryResponse getDashboardSummary(Integer year) {
    ExportAnalyticsDomainService.DashboardSummary summary =
        exportAnalyticsDomainService.generateDashboardSummary(year);
    return DashboardSummaryResponse.from(summary);
}
```

**문제**:
- `generateDashboardSummary` 메서드는 7개의 집계 쿼리 실행 (총 수출액, 국가 수, 품목 수, 상위 국가/품목, 월별 트렌드)
- 초기 요청 시 캐시 미스 시 응답 시간 5-10초 소요 가능
- 프론트엔드 UX 저하 (`DashboardView.vue:12-14` - 로딩 스피너만 표시)

**RabbitMQ 적용 제안**:

```
[년도 변경 시]
    → RabbitMQ: analytics.dashboard.request
        ↓
    Worker: Dashboard Analytics Worker
        → 집계 쿼리 실행
        → 결과를 Redis에 캐싱
        → WebSocket/SSE로 프론트엔드에 알림
```

**구현 예시**:
```java
// Application Service
public void requestDashboardSummary(Integer year) {
    DashboardAnalyticsRequest request = new DashboardAnalyticsRequest(year);
    rabbitTemplate.convertAndSend("analytics.dashboard.request", request);
}

// Worker (별도 Consumer)
@RabbitListener(queues = "dashboard-analytics-queue")
public void processDashboardAnalytics(DashboardAnalyticsRequest request) {
    DashboardSummary summary = analyticsService.generateDashboardSummary(request.getYear());
    redisTemplate.opsForValue().set("dashboard-summary:" + request.getYear(), summary, 10, TimeUnit.MINUTES);
    webSocketService.notifyDashboardReady(request.getYear());
}
```

### 2.3 우선순위 중간: 대용량 통계 재계산

**위치**: `ExportStatisticDomainService.java:164-167`

```java
public void batchUpdateGrowthRatesAndMarketShares(List<ExportStatistic> statistics) {
    statistics.forEach(this::calculateAndUpdateGrowthRate);
    statistics.forEach(this::calculateAndUpdateMarketShare);
}
```

**문제**:
- 수천~수만 건의 통계 데이터 재계산 시 동기 처리로 타임아웃 발생 가능
- 관세청 API로 데이터 입수 후 전체 통계 재계산 필요

**RabbitMQ 적용 제안**:

```
[배치 완료 후]
    → RabbitMQ: statistics.recalculation.request
        ↓
    Work Queue (여러 Worker)
        → 청크 단위로 통계 재계산 (예: 1000건씩)
        → DB 업데이트
        → 진행률을 Redis에 기록
```

### 2.4 우선순위 중간: 임계값 초과 알림

**위치**: `ExportStatistic.java:301-325`

```java
private void checkAndPublishThresholdEvent(Money currentValue) {
    var threshold = Money.usd(new BigDecimal("1000000"));

    if (currentValue.amount().compareTo(threshold.amount()) > 0) {
        var event = new ExportThresholdExceeded(
            UUID.randomUUID(),
            Instant.now(),
            getAggregateId(),
            thresholdData
        );
        registerEvent(event); // 현재는 발행되지 않음!
    }
}
```

**RabbitMQ 적용 제안**:

```
[ExportStatistic 업데이트 시]
    → 임계값 체크
    → RabbitMQ: export.threshold.exceeded
        ↓
    Queue 1: notification-queue
        → Slack/Email 알림 발송

    Queue 2: analytics-queue
        → 이상 패턴 분석 (급격한 증가/감소)
        → 대시보드에 경고 표시
```

### 2.5 우선순위 낮음: 캐시 워밍 (Cache Warming)

**현재 상황**:
- Redis 캐시가 설정되어 있지만 (`RedisConfig.java`), 초기 요청 시 캐시 미스
- 프론트엔드가 매번 대기해야 함

**RabbitMQ 적용 제안**:

```
[데이터 업데이트 완료 시]
    → RabbitMQ: cache.warming.request
        ↓
    Worker: Cache Warming Worker
        → 주요 대시보드 API 미리 호출
        → Redis 캐시 사전 생성
```

---

## 3. 이벤트 드리븐 아키텍처 적용 영역

### 3.1 우선순위 최상: 도메인 이벤트 발행 인프라 구축

**현재 문제**:
- 도메인 이벤트가 정의되어 있지만 발행되지 않음
- `AggregateRoot.java:15-40` - 이벤트가 메모리에만 저장됨

**해결 방안**:

#### 옵션 1: Spring Events (간단한 시작)
```java
@Component
public class DomainEventPublisher {
    private final ApplicationEventPublisher eventPublisher;

    @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)
    public void publishEvents(AfterCommitEvent event) {
        event.getEntity().getDomainEvents().forEach(eventPublisher::publishEvent);
        event.getEntity().clearDomainEvents();
    }
}
```

#### 옵션 2: RabbitMQ + Outbox Pattern (프로덕션 권장)
```java
@Component
public class RabbitMQDomainEventPublisher {
    private final RabbitTemplate rabbitTemplate;
    private final OutboxRepository outboxRepository;

    @Transactional
    public void publishDomainEvents(AggregateRoot aggregate) {
        aggregate.getDomainEvents().forEach(event -> {
            // Outbox 패턴: 이벤트를 DB에 먼저 저장 (트랜잭션 일관성)
            OutboxMessage outbox = new OutboxMessage(
                event.eventId(),
                event.eventType(),
                event.aggregateId(),
                serializeEvent(event),
                OutboxStatus.PENDING
            );
            outboxRepository.save(outbox);
        });
        aggregate.clearDomainEvents();
    }
}

// 별도 스케줄러가 Outbox 테이블 폴링하여 RabbitMQ로 발행
@Scheduled(fixedDelay = 1000)
public void processOutbox() {
    List<OutboxMessage> pending = outboxRepository.findByStatus(OutboxStatus.PENDING);
    pending.forEach(msg -> {
        rabbitTemplate.convertAndSend(
            "domain.events",
            msg.getEventType(),
            msg.getPayload()
        );
        msg.setStatus(OutboxStatus.PUBLISHED);
        outboxRepository.save(msg);
    });
}
```

### 3.2 우선순위 높음: 통계 생성/업데이트 이벤트 기반 처리

**현재 플로우**:
```java
// ExportStatisticApplicationService.java:54-88
@Transactional
public ExportStatisticResponse createExportStatistic(CreateExportStatisticRequest request) {
    // 1. 통계 생성
    ExportStatistic statistic = ExportStatistic.create(...);

    // 2. 도메인 서비스로 비즈니스 로직 실행 (동기)
    exportStatisticDomainService.validateExportDataConsistency(statistic);
    exportStatisticDomainService.calculateAndUpdateGrowthRate(statistic);
    exportStatisticDomainService.calculateAndUpdateMarketShare(statistic);

    // 3. 저장
    ExportStatistic savedStatistic = exportStatisticRepository.save(statistic);

    return ExportStatisticResponse.from(savedStatistic);
}
```

**문제**:
- 성장률/시장점유율 계산이 동기적으로 실행되어 응답 지연
- 특히 전년도 데이터 조회 쿼리 (`calculateAndUpdateGrowthRate`)

**이벤트 드리븐 리팩토링**:

```java
@Transactional
public ExportStatisticResponse createExportStatistic(CreateExportStatisticRequest request) {
    // 1. 통계 생성
    ExportStatistic statistic = ExportStatistic.create(...);

    // 2. 기본 검증만 실행
    exportStatisticDomainService.validateExportDataConsistency(statistic);

    // 3. 저장 (이벤트 발행)
    ExportStatistic savedStatistic = exportStatisticRepository.save(statistic);

    // 4. 이벤트 발행 (비동기 처리)
    publishDomainEvents(savedStatistic); // ExportStatisticCreated 이벤트

    return ExportStatisticResponse.from(savedStatistic);
}

// 이벤트 핸들러 (별도 트랜잭션)
@RabbitListener(queues = "export.statistic.created")
@Transactional
public void handleExportStatisticCreated(ExportStatisticCreatedEvent event) {
    ExportStatistic statistic = repository.findById(event.getStatisticId()).orElseThrow();

    // 비동기로 복잡한 계산 실행
    exportStatisticDomainService.calculateAndUpdateGrowthRate(statistic);
    exportStatisticDomainService.calculateAndUpdateMarketShare(statistic);

    repository.save(statistic);

    // 캐시 무효화 이벤트 발행
    publishEvent(new CacheInvalidationEvent("dashboard-summary", statistic.getPeriod().year()));
}
```

### 3.3 우선순위 높음: Saga 패턴 - 국가 비활성화 시 통계 처리

**시나리오**:
국가가 비활성화되면 관련 통계 데이터 처리 필요 (아카이빙, 대시보드에서 제외 등)

**현재**: 이벤트는 발행되지만 처리되지 않음 (`Country.java:110-133`)

**Saga 패턴 적용**:

```
[Country.deactivate()]
    → CountryDeactivated 이벤트 발행
        ↓
    Step 1: ExportStatistic 아카이빙
        → export.statistics.archived 이벤트 발행

    Step 2: 캐시 무효화
        → cache.invalidated 이벤트 발행

    Step 3: 대시보드 재계산
        → dashboard.recalculation.completed 이벤트 발행

    Step 4: 관리자 알림
        → notification.sent 이벤트 발행
```

**구현 예시**:
```java
@RabbitListener(queues = "country.deactivated")
public void handleCountryDeactivated(CountryDeactivatedEvent event) {
    CountryDeactivationSaga saga = new CountryDeactivationSaga(event.getCountryCode());

    // Step 1
    List<ExportStatistic> statistics = repository.findByCountryCode(event.getCountryCode());
    archiveStatistics(statistics);
    saga.markArchiveCompleted();

    // Step 2
    cacheManager.evictByCountry(event.getCountryCode());
    saga.markCacheEvicted();

    // Step 3
    requestDashboardRecalculation(event.getYear());
    saga.markRecalculationRequested();

    // Step 4 (보상 트랜잭션 가능)
    if (saga.isCompleted()) {
        notificationService.notifyAdmins("국가 비활성화 완료: " + event.getCountryCode());
    } else {
        saga.compensate(); // 롤백
    }
}
```

### 3.4 우선순위 중간: CQRS 패턴 - 읽기/쓰기 분리

**현재 문제**:
- 복잡한 집계 쿼리가 트랜잭셔널 DB에서 실행됨 (`ExportAnalyticsDomainService.java:29-217`)
- 대시보드 조회 성능 저하 가능성

**CQRS 적용 제안**:

```
[Write Model - PostgreSQL]
    ExportStatistic 생성/수정
    → export.statistic.created 이벤트 발행
        ↓
[Event Bus - RabbitMQ]
        ↓
[Read Model - MongoDB/Elasticsearch]
    사전 집계된 뷰 저장:
    - 년도별 대시보드 요약
    - 국가별 통계
    - 품목별 통계
    - 월별 트렌드
```

**이점**:
- 읽기 성능 대폭 향상
- 복잡한 조인 없이 denormalized 데이터 제공
- 프론트엔드 응답 시간 < 100ms

### 3.5 우선순위 낮음: 실시간 알림/업데이트

**현재**: 프론트엔드가 폴링 방식으로 데이터 갱신 (`DashboardView.vue:120-127`)

**WebSocket + RabbitMQ 적용**:

```
[배치 완료/통계 업데이트]
    → RabbitMQ: dashboard.update.notification
        ↓
    WebSocket Handler
        → 연결된 클라이언트에게 실시간 알림
        → "새로운 데이터가 업데이트되었습니다. 새로고침하시겠습니까?"
```

---

## 4. 구체적인 적용 제안 및 우선순위

### Phase 1: 기반 인프라 구축 (1-2주)

**작업 내용**:
1. **RabbitMQ 통합**
   - `pom.xml`에 `spring-boot-starter-amqp` 추가
   - `RabbitMQConfig.java` 생성 (Exchange, Queue, Binding 설정)
   - Docker Compose에 RabbitMQ 추가

```yaml
# docker-compose.yml 추가
rabbitmq:
  image: rabbitmq:3.12-management-alpine
  container_name: export-dashboard-rabbitmq
  ports:
    - "5672:5672"
    - "15672:15672"
  environment:
    RABBITMQ_DEFAULT_USER: export_user
    RABBITMQ_DEFAULT_PASS: export_password
  volumes:
    - rabbitmq_data:/var/lib/rabbitmq
```

2. **도메인 이벤트 발행 메커니즘 구축**
   - `DomainEventPublisher.java` 생성
   - `OutboxMessage` 엔티티 및 Repository 생성
   - JPA Listener를 활용한 자동 이벤트 발행

3. **기본 이벤트 핸들러 구현**
   - `ExportStatisticCreatedEventHandler.java`
   - 간단한 로깅부터 시작

**예상 이점**:
- 도메인 이벤트가 실제로 활용되기 시작
- 이후 기능 확장의 기반 마련

### Phase 2: 관세청 API 배치 작업 (2-3주)

**작업 내용**:
1. **Spring Batch + RabbitMQ 통합**
   - Excel 처리를 RabbitMQ 메시지로 분산
   - API 호출을 Rate-limited Queue로 제어
   - Dead Letter Queue로 실패 처리

2. **이벤트 체인 구축**
   ```
   customs.excel.processed
   → customs.api.request
   → customs.data.received
   → export.statistic.created
   → analytics.recalculation.request
   ```

**예상 이점**:
- API 장애에 강건한 배치 프로세스
- 처리 진행 상황 실시간 모니터링
- Worker 확장으로 처리 속도 조절 가능

### Phase 3: 대시보드 성능 최적화 (1-2주)

**작업 내용**:
1. **비동기 대시보드 생성**
   - 대시보드 요청 시 즉시 응답 (202 Accepted)
   - 백그라운드에서 계산 후 WebSocket으로 알림

2. **캐시 워밍 자동화**
   - 데이터 업데이트 시 자동으로 주요 캐시 재생성

**예상 이점**:
- 사용자 응답 시간 < 500ms
- 서버 부하 분산

### Phase 4: CQRS 패턴 적용 (선택적, 3-4주)

**작업 내용**:
1. **Read Model 구축**
   - MongoDB 또는 Elasticsearch 도입
   - 사전 집계된 뷰 생성

2. **이벤트 소싱**
   - 모든 통계 변경을 이벤트로 저장
   - 시점별 데이터 재구성 가능

**예상 이점**:
- 대규모 데이터에서도 일관된 성능
- 복잡한 분석 쿼리 최적화

---

## 5. 구현 시 고려사항

### 5.1 메시지 순서 보장

**문제**:
동일 통계에 대한 업데이트 이벤트가 순서대로 처리되어야 함

**해결**:
- RabbitMQ Consistent Hash Exchange 사용
- Routing Key를 `{countryCode}-{hsCode}-{year}-{month}`로 설정하여 동일 통계는 같은 Queue로 라우팅

### 5.2 멱등성 (Idempotency)

**문제**:
메시지가 중복 처리될 수 있음

**해결**:
```java
@Transactional
public void handleExportStatisticCreated(ExportStatisticCreatedEvent event) {
    // 이벤트 ID로 중복 체크
    if (processedEventRepository.existsByEventId(event.getEventId())) {
        log.warn("이미 처리된 이벤트: {}", event.getEventId());
        return;
    }

    // 처리 로직
    // ...

    // 처리 완료 기록
    processedEventRepository.save(new ProcessedEvent(event.getEventId()));
}
```

### 5.3 Dead Letter Queue 및 재시도 전략

```java
@Bean
public SimpleRabbitListenerContainerFactory rabbitListenerContainerFactory(
        ConnectionFactory connectionFactory) {
    SimpleRabbitListenerContainerFactory factory = new SimpleRabbitListenerContainerFactory();
    factory.setConnectionFactory(connectionFactory);

    // 재시도 설정
    factory.setDefaultRequeueRejected(false);
    factory.setAdviceChain(
        RetryInterceptorBuilder.stateless()
            .maxAttempts(3)
            .backOffOptions(1000, 2.0, 10000) // Exponential backoff
            .recoverer(new RepublishMessageRecoverer(rabbitTemplate, "dlx.exchange"))
            .build()
    );

    return factory;
}
```

### 5.4 모니터링 및 관찰성

**필수 도구**:
1. **RabbitMQ Management Plugin**: Queue 깊이, 메시지 처리율 모니터링
2. **Spring Boot Actuator**: 메트릭 수집
3. **분산 추적**: Spring Cloud Sleuth + Zipkin 통합

```java
// 메트릭 수집
@Component
public class EventMetrics {
    private final MeterRegistry meterRegistry;

    public void recordEventPublished(String eventType) {
        meterRegistry.counter("domain.events.published", "type", eventType).increment();
    }

    public void recordEventProcessed(String eventType, long processingTimeMs) {
        meterRegistry.timer("domain.events.processed", "type", eventType)
            .record(processingTimeMs, TimeUnit.MILLISECONDS);
    }
}
```

### 5.5 트랜잭션 경계 및 일관성

**Outbox 패턴 필수**:
```sql
CREATE TABLE outbox_messages (
    id BIGSERIAL PRIMARY KEY,
    event_id UUID UNIQUE NOT NULL,
    event_type VARCHAR(100) NOT NULL,
    aggregate_id VARCHAR(255) NOT NULL,
    payload JSONB NOT NULL,
    status VARCHAR(20) NOT NULL, -- PENDING, PUBLISHED, FAILED
    created_at TIMESTAMP NOT NULL DEFAULT NOW(),
    published_at TIMESTAMP
);

CREATE INDEX idx_outbox_status ON outbox_messages(status, created_at);
```

---

## 6. 예상 이점 요약

### 성능 개선
- **대시보드 초기 로딩**: 5-10초 → 500ms 이하
- **배치 처리**: 단일 스레드 → 분산 처리로 3-5배 속도 향상
- **API 응답 시간**: 복잡한 분석 작업을 비동기 처리로 즉시 응답

### 확장성
- **수평 확장**: Worker 인스턴스 추가로 처리 용량 증가
- **부하 분산**: 메시지 큐로 트래픽 스파이크 흡수

### 신뢰성
- **장애 격리**: 한 컴포넌트 장애가 전체 시스템에 영향 주지 않음
- **자동 재시도**: API 일시적 장애 자동 복구
- **데이터 일관성**: Outbox 패턴으로 이벤트 발행 보장

### 유지보수성
- **느슨한 결합**: 도메인 모듈 간 의존성 감소
- **기능 추가 용이**: 새 이벤트 핸들러 추가만으로 기능 확장
- **테스트 용이성**: 각 핸들러를 독립적으로 테스트

---

## 7. 최종 권장 사항

### 즉시 착수 (Phase 1)
1. RabbitMQ 인프라 구축
2. 도메인 이벤트 발행 메커니즘 구현
3. Outbox 패턴 적용

### 단기 목표 (1-2개월)
1. 관세청 API 배치 작업을 RabbitMQ 기반으로 구현
2. 대시보드 분석 작업 비동기 처리
3. 실시간 알림 기능 추가

### 중장기 목표 (3-6개월)
1. CQRS 패턴으로 읽기 성능 최적화
2. 이벤트 소싱 도입 (시점별 데이터 분석)
3. 마이크로서비스 분리 검토 (Analytics 서비스, Batch 서비스)

### 핵심 메시지
현재 프로젝트는 이미 도메인 이벤트 구조를 가지고 있어 이벤트 드리븐 아키텍처로의 전환이 상대적으로 수월합니다. RabbitMQ 도입으로 성능, 확장성, 신뢰성을 크게 향상시킬 수 있습니다.

---

## 참고 자료

### RabbitMQ 공식 문서
- [RabbitMQ Tutorials](https://www.rabbitmq.com/getstarted.html)
- [Spring AMQP Reference](https://docs.spring.io/spring-amqp/reference/)

### 이벤트 드리븐 아키텍처 패턴
- [Microservices.io - Event Sourcing](https://microservices.io/patterns/data/event-sourcing.html)
- [Martin Fowler - Event Sourcing](https://martinfowler.com/eaaDev/EventSourcing.html)
- [Saga Pattern](https://microservices.io/patterns/data/saga.html)
- [Outbox Pattern](https://microservices.io/patterns/data/transactional-outbox.html)

### CQRS
- [Martin Fowler - CQRS](https://martinfowler.com/bliki/CQRS.html)
- [Microsoft - CQRS Pattern](https://docs.microsoft.com/en-us/azure/architecture/patterns/cqrs)
